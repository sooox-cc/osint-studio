import { useState } from "react";
import { invoke } from "@tauri-apps/api/core";
import { save } from "@tauri-apps/plugin-dialog";
import { X, Download } from "lucide-react";

interface Node {
  id: string;
  node_type: string;
  label: string;
  description?: string;
  tags: string[];
  created_at: string;
  updated_at: string;
  confidence: number;
}

interface Relationship {
  id: string;
  source_id: string;
  target_id: string;
  relation_type: string;
  description?: string;
  weight: number;
  confidence: number;
  created_at: string;
  source?: string;
}

interface ReportGeneratorProps {
  nodes: Node[];
  relationships: Relationship[];
  onClose: () => void;
}

const ReportGenerator = ({ nodes, relationships, onClose }: ReportGeneratorProps) => {
  const [reportType, setReportType] = useState<"investigation" | "summary" | "timeline">("investigation");
  const [includeConfidenceScores, setIncludeConfidenceScores] = useState(true);
  const [includeMetadata, setIncludeMetadata] = useState(true);
  const [projectTitle, setProjectTitle] = useState("OSINT Investigation Report");
  const [investigatorName, setInvestigatorName] = useState("");
  const [loading, setLoading] = useState(false);

  const generateInvestigationReport = () => {
    const nodesByType = nodes.reduce((acc, node) => {
      if (!acc[node.node_type]) acc[node.node_type] = [];
      acc[node.node_type].push(node);
      return acc;
    }, {} as Record<string, Node[]>);

    const highConfidenceRels = relationships.filter(rel => rel.confidence >= 0.8);
    const mediumConfidenceRels = relationships.filter(rel => rel.confidence >= 0.5 && rel.confidence < 0.8);
    const lowConfidenceRels = relationships.filter(rel => rel.confidence < 0.5);

    const report = `# ${projectTitle}

## Investigation Summary
**Date Generated:** ${new Date().toLocaleDateString()}
**Investigator:** ${investigatorName || "Unknown"}
**Total Entities:** ${nodes.length}
**Total Relationships:** ${relationships.length}

## Entity Breakdown
${Object.entries(nodesByType).map(([type, typeNodes]) => 
  `### ${type} (${typeNodes.length})\n${typeNodes.map(node => 
    `- **${node.label}**${includeConfidenceScores ? ` (${Math.round(node.confidence * 100)}% confidence)` : ''}${node.description ? `\n  ${node.description}` : ''}${node.tags.length > 0 ? `\n  Tags: ${node.tags.join(', ')}` : ''}`
  ).join('\n')}`
).join('\n\n')}

## Relationship Analysis

### High Confidence Relationships (â‰¥80%)
${highConfidenceRels.length > 0 ? highConfidenceRels.map(rel => {
  const sourceNode = nodes.find(n => n.id === rel.source_id);
  const targetNode = nodes.find(n => n.id === rel.target_id);
  return `- **${sourceNode?.label || 'Unknown'}** ${rel.relation_type.toLowerCase()} **${targetNode?.label || 'Unknown'}**${includeConfidenceScores ? ` (${Math.round(rel.confidence * 100)}%)` : ''}${rel.description ? `\n  ${rel.description}` : ''}${rel.source ? `\n  Source: ${rel.source}` : ''}`;
}).join('\n') : 'No high confidence relationships found.'}

### Medium Confidence Relationships (50-79%)
${mediumConfidenceRels.length > 0 ? mediumConfidenceRels.map(rel => {
  const sourceNode = nodes.find(n => n.id === rel.source_id);
  const targetNode = nodes.find(n => n.id === rel.target_id);
  return `- **${sourceNode?.label || 'Unknown'}** ${rel.relation_type.toLowerCase()} **${targetNode?.label || 'Unknown'}**${includeConfidenceScores ? ` (${Math.round(rel.confidence * 100)}%)` : ''}${rel.description ? `\n  ${rel.description}` : ''}`;
}).join('\n') : 'No medium confidence relationships found.'}

### Low Confidence Relationships (<50%)
${lowConfidenceRels.length > 0 ? `${lowConfidenceRels.length} relationships require further investigation.` : 'No low confidence relationships found.'}

## Key Findings
- **Most Connected Entity:** ${getMostConnectedEntity()}
- **Relationship Types:** ${[...new Set(relationships.map(r => r.relation_type))].join(', ')}
- **Average Confidence Score:** ${Math.round(relationships.reduce((sum, rel) => sum + rel.confidence, 0) / relationships.length * 100)}%

## Recommendations
- Verify low confidence relationships with additional sources
- Focus investigation on high-connectivity entities
- Cross-reference findings with external databases

${includeMetadata ? `
## Technical Metadata
- **Export Date:** ${new Date().toISOString()}
- **Tool:** OSINT Studio
- **Data Quality Score:** ${getDataQualityScore()}%
` : ''}

---
*This report was automatically generated by OSINT Studio*
`;

    return report;
  };

  const generateSummaryReport = () => {
    const entityTypes = [...new Set(nodes.map(n => n.node_type))];
    const relationTypes = [...new Set(relationships.map(r => r.relation_type))];
    
    return `# ${projectTitle} - Executive Summary

## Overview
This investigation analyzed ${nodes.length} entities and ${relationships.length} relationships to map connections and identify patterns of interest.

## Key Statistics
- **Entity Types:** ${entityTypes.join(', ')}
- **Relationship Types:** ${relationTypes.join(', ')}
- **High Confidence Links:** ${relationships.filter(r => r.confidence >= 0.8).length}
- **Investigation Period:** ${getInvestigationPeriod()}

## Critical Entities
${getTopEntities(5).map(entity => 
  `- **${entity.label}** (${entity.node_type}) - ${getEntityConnections(entity.id)} connections`
).join('\n')}

## Network Analysis
- **Most Connected:** ${getMostConnectedEntity()}
- **Relationship Density:** ${Math.round(relationships.length / nodes.length * 100)}%
- **Average Confidence:** ${Math.round(relationships.reduce((sum, rel) => sum + rel.confidence, 0) / relationships.length * 100)}%

## Next Steps
1. Investigate low confidence relationships
2. Expand analysis of key entities
3. Cross-reference with additional data sources

---
*Generated on ${new Date().toLocaleDateString()} by ${investigatorName || 'OSINT Studio'}*
`;
  };

  const generateTimelineReport = () => {
    const sortedEvents = [...nodes, ...relationships]
      .map(item => ({
        ...item,
        type: 'id' in item && 'source_id' in item ? 'relationship' : 'entity',
        date: new Date(item.created_at)
      }))
      .sort((a, b) => a.date.getTime() - b.date.getTime());

    return `# ${projectTitle} - Timeline Report

## Investigation Timeline
${sortedEvents.map(event => {
  const dateStr = event.date.toLocaleDateString();
  if (event.type === 'entity') {
    const entity = event as Node;
    return `**${dateStr}** - Entity Added: ${entity.label} (${entity.node_type})`;
  } else {
    const rel = event as Relationship;
    const sourceNode = nodes.find(n => n.id === rel.source_id);
    const targetNode = nodes.find(n => n.id === rel.target_id);
    return `**${dateStr}** - Relationship: ${sourceNode?.label || 'Unknown'} ${rel.relation_type.toLowerCase()} ${targetNode?.label || 'Unknown'}`;
  }
}).join('\n')}

## Activity Summary
- **First Entry:** ${sortedEvents[0]?.date.toLocaleDateString() || 'N/A'}
- **Latest Entry:** ${sortedEvents[sortedEvents.length - 1]?.date.toLocaleDateString() || 'N/A'}
- **Investigation Duration:** ${getInvestigationDuration()} days
- **Entities Added:** ${nodes.length}
- **Relationships Established:** ${relationships.length}

---
*Timeline generated on ${new Date().toLocaleDateString()}*
`;
  };

  const getMostConnectedEntity = () => {
    const connections = nodes.map(node => ({
      ...node,
      connectionCount: relationships.filter(rel => 
        rel.source_id === node.id || rel.target_id === node.id
      ).length
    }));
    
    const mostConnected = connections.reduce((max, node) => 
      node.connectionCount > max.connectionCount ? node : max
    );
    
    return `${mostConnected.label} (${mostConnected.connectionCount} connections)`;
  };

  const getTopEntities = (count: number) => {
    return nodes
      .map(node => ({
        ...node,
        connections: relationships.filter(rel => 
          rel.source_id === node.id || rel.target_id === node.id
        ).length
      }))
      .sort((a, b) => b.connections - a.connections)
      .slice(0, count);
  };

  const getEntityConnections = (entityId: string) => {
    return relationships.filter(rel => 
      rel.source_id === entityId || rel.target_id === entityId
    ).length;
  };

  const getDataQualityScore = () => {
    const avgConfidence = nodes.reduce((sum, node) => sum + node.confidence, 0) / nodes.length;
    const relConfidence = relationships.reduce((sum, rel) => sum + rel.confidence, 0) / relationships.length;
    return Math.round((avgConfidence + relConfidence) / 2 * 100);
  };

  const getInvestigationPeriod = () => {
    const dates = [...nodes, ...relationships].map(item => new Date(item.created_at));
    const earliest = new Date(Math.min(...dates.map(d => d.getTime())));
    const latest = new Date(Math.max(...dates.map(d => d.getTime())));
    return `${earliest.toLocaleDateString()} - ${latest.toLocaleDateString()}`;
  };

  const getInvestigationDuration = () => {
    const dates = [...nodes, ...relationships].map(item => new Date(item.created_at));
    const earliest = new Date(Math.min(...dates.map(d => d.getTime())));
    const latest = new Date(Math.max(...dates.map(d => d.getTime())));
    return Math.ceil((latest.getTime() - earliest.getTime()) / (1000 * 60 * 60 * 24));
  };

  const handleGenerateReport = async () => {
    try {
      setLoading(true);
      
      let reportContent = "";
      let defaultFileName = "";
      
      switch (reportType) {
        case "investigation":
          reportContent = generateInvestigationReport();
          defaultFileName = "investigation-report.md";
          break;
        case "summary":
          reportContent = generateSummaryReport();
          defaultFileName = "executive-summary.md";
          break;
        case "timeline":
          reportContent = generateTimelineReport();
          defaultFileName = "timeline-report.md";
          break;
      }

      const filePath = await save({
        defaultPath: defaultFileName,
        filters: [
          {
            name: "Markdown Report",
            extensions: ["md"]
          },
          {
            name: "Text File",
            extensions: ["txt"]
          }
        ]
      });

      if (filePath) {
        await invoke("write_report", { 
          filePath: typeof filePath === 'string' ? filePath : String(filePath),
          content: reportContent 
        });
        alert("Report generated successfully!");
        onClose();
      }
    } catch (error) {
      console.error("Failed to generate report:", error);
      alert("Failed to generate report: " + error);
    } finally {
      setLoading(false);
    }
  };

  const handleOverlayClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget) {
      onClose();
    }
  };

  return (
    <div className="modal-overlay" onClick={handleOverlayClick}>
      <div className="modal-content report-generator">
        <div className="modal-header">
          <h3>Generate Investigation Report</h3>
          <button onClick={onClose} className="close-btn">
            <X size={16} />
          </button>
        </div>

        <div className="report-form">
          <div className="form-group">
            <label>Report Type</label>
            <select 
              value={reportType}
              onChange={(e) => setReportType(e.target.value as any)}
            >
              <option value="investigation">Full Investigation Report</option>
              <option value="summary">Executive Summary</option>
              <option value="timeline">Timeline Report</option>
            </select>
          </div>

          <div className="form-group">
            <label>Project Title</label>
            <input
              type="text"
              value={projectTitle}
              onChange={(e) => setProjectTitle(e.target.value)}
              placeholder="Enter report title..."
            />
          </div>

          <div className="form-group">
            <label>Investigator Name</label>
            <input
              type="text"
              value={investigatorName}
              onChange={(e) => setInvestigatorName(e.target.value)}
              placeholder="Your name (optional)"
            />
          </div>

          <div className="form-group">
            <label className="checkbox-label">
              <input
                type="checkbox"
                checked={includeConfidenceScores}
                onChange={(e) => setIncludeConfidenceScores(e.target.checked)}
              />
              Include confidence scores
            </label>
          </div>

          <div className="form-group">
            <label className="checkbox-label">
              <input
                type="checkbox"
                checked={includeMetadata}
                onChange={(e) => setIncludeMetadata(e.target.checked)}
              />
              Include technical metadata
            </label>
          </div>

          <div className="report-preview">
            <h4>Report Preview</h4>
            <div className="preview-stats">
              <span>ðŸ“Š {nodes.length} entities</span>
              <span>ðŸ”— {relationships.length} relationships</span>
              <span>ðŸŽ¯ {relationships.filter(r => r.confidence >= 0.8).length} high confidence links</span>
            </div>
          </div>

          <div className="form-actions">
            <button 
              onClick={handleGenerateReport}
              disabled={loading}
              className="generate-btn"
            >
              <Download size={16} />
              {loading ? "Generating..." : "Generate Report"}
            </button>
            <button onClick={onClose} className="cancel-btn">
              Cancel
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default ReportGenerator;